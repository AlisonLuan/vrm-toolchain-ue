name: CI Lite (No UE)

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  gates:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: No tracked artifacts gate
        shell: pwsh
        run: |
          $errors = @()

          if (git ls-files | Select-String -Pattern '^build/') { $errors += "Tracked files under build/ (must be untracked)." }
          if (git ls-files | Select-String -Pattern 'BuildOutput\.log') { $errors += "BuildOutput.log is tracked (must be ignored)." }
          if (git ls-files | Select-String -Pattern '\.zip$') { $errors += "A .zip is tracked (must be untracked)." }

          if ($errors.Count -gt 0) {
            $errors | ForEach-Object { Write-Error $_ }
            exit 1
          }

      - name: Header + include style gates
        shell: pwsh
        run: |
          function Get-GrepLines([string]$Pattern, [string]$Path) {
            # git grep exits 1 when no matches; treat that as "0 hits" not a failure.
            $out = git grep -n $Pattern -- $Path 2>$null
            $code = $LASTEXITCODE
            if ($code -eq 0) { return @($out) }
            if ($code -eq 1) { return @() }
            throw "git grep failed with exit code $code for pattern: $Pattern"
          }

          # Canonical header count (exactly 1 tracked file each)
          $m1 = (git ls-files | Select-String "VrmMetadata\.h").Count
          $m2 = (git ls-files | Select-String "VrmMetadataAsset\.h").Count
          if ($m1 -ne 1) { throw "Expected exactly 1 tracked VrmMetadata.h, found $m1" }
          if ($m2 -ne 1) { throw "Expected exactly 1 tracked VrmMetadataAsset.h, found $m2" }

          # Explicit canonical path checks to prevent regression
          $canonMeta  = 'Plugins/VrmToolchain/Source/VrmToolchain/Public/VrmToolchain/VrmMetadata.h'
          $canonAsset = 'Plugins/VrmToolchain/Source/VrmToolchain/Public/VrmToolchain/VrmMetadataAsset.h'
          if (-not (git ls-files -- $canonMeta))  { throw "Missing canonical header: $canonMeta" }
          if (-not (git ls-files -- $canonAsset)) { throw "Missing canonical header: $canonAsset" }

          # Legacy includes must be absent
          $legacy1 = Get-GrepLines '#include "VrmMetadata\.h"' 'Plugins/VrmToolchain/Source'
          $legacy2 = Get-GrepLines '#include "VrmMetadataAsset\.h"' 'Plugins/VrmToolchain/Source'
          if ($legacy1.Count -gt 0) { throw "Found legacy include '#include ""VrmMetadata.h""':`n$($legacy1 -join "`n")" }
          if ($legacy2.Count -gt 0) { throw "Found legacy include '#include ""VrmMetadataAsset.h""':`n$($legacy2 -join "`n")" }

          # Namespaced includes must exist
          $ns1 = Get-GrepLines 'VrmToolchain/VrmMetadata\.h' 'Plugins/VrmToolchain/Source'
          $ns2 = Get-GrepLines 'VrmToolchain/VrmMetadataAsset\.h' 'Plugins/VrmToolchain/Source'
          if ($ns1.Count -lt 1) { throw "Missing namespaced include usage for VrmToolchain/VrmMetadata.h" }
          if ($ns2.Count -lt 1) { throw "Missing namespaced include usage for VrmToolchain/VrmMetadataAsset.h" }

          # Ensure the step exits cleanly even if last git grep had no matches earlier
          $global:LASTEXITCODE = 0

      - name: Runtime must not reference editor-only modules
        shell: pwsh
        run: |
          $EditorOnly = @(
            "UnrealEd","ToolMenus","ContentBrowser","AssetTools","LevelEditor",
            "Kismet","KismetCompiler","BlueprintGraph","EditorSubsystem","EditorFramework"
          )

          function Strip-CSharpComments([string]$Text) {
            # Remove /* */ block comments
            $noBlock = [regex]::Replace($Text, '/\*.*?\*/', '', 'Singleline')
            # Remove // line comments
            $noLine  = [regex]::Replace($noBlock, '//.*$', '', 'Multiline')
            return $noLine
          }

          $RuntimeBuildCs = Get-ChildItem "Plugins\VrmToolchain\Source" -Recurse -Filter "*.Build.cs" |
            Where-Object { $_.FullName -notmatch "Editor" -and $_.Name -match "\.Build\.cs" }

          $bad = @()
          foreach($f in $RuntimeBuildCs){
            $raw = Get-Content $f.FullName -Raw
            $t = Strip-CSharpComments $raw
            foreach($m in $EditorOnly){
              if($t -match [regex]::Escape($m)){
                $bad += ("{0}: contains '{1}'" -f $f.FullName,$m)
              }
            }
          }

          if($bad.Count -gt 0){
            $bad | ForEach-Object { Write-Error $_ }
            exit 1
          }

      - name: PackagePlugin must call ValidatePackage (static check)
        shell: pwsh
        run: |
          $pkg = Get-Content "Scripts\PackagePlugin.ps1" -Raw
          if ($pkg -notmatch "ValidatePackage\.ps1") {
            throw "Scripts/PackagePlugin.ps1 does not appear to call Scripts/ValidatePackage.ps1"
          }
