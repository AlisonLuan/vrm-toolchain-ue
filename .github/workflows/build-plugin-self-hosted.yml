name: Build plugin (self-hosted)

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: build-plugin-self-hosted-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-plugin:
    runs-on: [self-hosted, windows, ue-5.7]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine changed files (PR files via API)
        id: changed
        shell: pwsh
        run: |
          # Use GitHub API to list PR files when running on pull_request events; fallback to git diffs when needed
          $changed = ""
          if ($env:GITHUB_EVENT_NAME -eq 'pull_request') {
            try {
              if ($env:GITHUB_EVENT_PATH) {
                $event = Get-Content $env:GITHUB_EVENT_PATH | ConvertFrom-Json
                $prnum = $event.pull_request.number
                $repo = $env:GITHUB_REPOSITORY
                Write-Host "Querying PR files for PR #$prnum in $repo"
                $files = gh api repos/$repo/pulls/$prnum/files -q '.[].filename' 2>$null | Out-String
                if ($files -and $files.Trim()) {
                  $changed = $files
                } else {
                  Write-Warning "GitHub API returned no files; falling back to git diff origin/main...HEAD"
                  git fetch origin main --no-tags --prune
                  $changed = (& git diff --name-only origin/main...HEAD 2>&1)
                }
              } else {
                Write-Warning "GITHUB_EVENT_PATH not set; falling back to git diff origin/main...HEAD"
                git fetch origin main --no-tags --prune
                $changed = (& git diff --name-only origin/main...HEAD 2>&1)
              }
            } catch {
              Write-Warning "Error while querying GitHub API for PR files: $_; falling back to git diff origin/main...HEAD"
              git fetch origin main --no-tags --prune
              $changed = (& git diff --name-only origin/main...HEAD 2>&1)
            }
          } else {
            # Non-PR: prefer HEAD~1, but fall back to origin/main if history is shallow
            $useOrigin = $false
            $revCheck = & git rev-parse --verify HEAD~1 2>&1
            if ($LASTEXITCODE -ne 0) { $useOrigin = $true }

            if (-not $useOrigin) {
              $out = & git diff --name-only HEAD~1 HEAD 2>&1
              if ($LASTEXITCODE -ne 0) {
                Write-Warning "git diff HEAD~1 HEAD failed ($LASTEXITCODE): $out; falling back to origin/main...HEAD"
                git fetch origin main --no-tags --prune
                $changed = (& git diff --name-only origin/main...HEAD 2>&1)
              } else {
                $changed = $out
              }
            } else {
              git fetch origin main --no-tags --prune
              $changed = (& git diff --name-only origin/main...HEAD 2>&1)
            }
          }

          Write-Host "Changed files:`n$changed"

          # Normalize and trim
          $files = ($changed -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' })
          $nonDocs = @()
          foreach ($f in $files) {
            # Treat workflow edits as non-doc changes (force full CI)
            if ($f -match '^\.github/workflows/') { $nonDocs += $f; continue }
            # Files considered docs-only
            if ($f -match '^(Docs/|README.md$|LICENSE$|CHANGELOG$)') { continue }
            # Other .github/meta files are docs-like (allowed)
            if ($f -match '^\.github/') { continue }
            # Anything else is non-doc
            $nonDocs += $f
          }

          if ($nonDocs.Count -eq 0) {
            echo "docs_only=true" >> $env:GITHUB_OUTPUT
            Write-Host "Docs-only change detected"
          } else {
            echo "docs_only=false" >> $env:GITHUB_OUTPUT
            Write-Host "Non-doc changes detected: $($nonDocs -join ', ')"
          }

          exit 0

      - name: "Lint workflows: forbid -AllowBinaries"
        shell: pwsh
        run: |
          # Fail if any workflow calls PackagePlugin.ps1 with -AllowBinaries (forbidden by policy)
          $violations = @()
          foreach ($file in Get-ChildItem ".github/workflows/*.yml") {
            $lines = @(Get-Content $file -Encoding UTF8)
            $inRunBlock = $false
            for ($i = 0; $i -lt $lines.Count; $i++) {
              $line = $lines[$i]
              if ($line -match '^\s+run:\s*[\|\>]') { $inRunBlock = $true }
              if ($inRunBlock -and $line -match '^\s+- ') { $inRunBlock = $false }
              # Only check invocation lines: starts with .\ and actual PackagePlugin.ps1 call
              if ($inRunBlock -and $line -match '^\s+\.\\\Scripts\\PackagePlugin' -and $line -match '-AllowBinaries') {
                $violations += "$($file.Name):$($i+1)"
              }
            }
          }
          if ($violations) {
            $violations | ForEach-Object { Write-Error "Forbidden -AllowBinaries: $_" }
            throw "CI forbids PackagePlugin.ps1 with -AllowBinaries"
          }
          Write-Host "OK: Workflows do not call PackagePlugin.ps1 with -AllowBinaries"

      - name: Fetch VRM SDK
        shell: pwsh
        env:
          VRM_SDK_TOKEN: ${{ secrets.VRM_SDK_TOKEN }}
        run: .\Scripts\FetchVrmSdk.ps1

      - name: Verify SDK lib layout (Debug/Release present)
        shell: pwsh
        run: |
          $root = Join-Path $PWD 'Plugins\VrmToolchain\Source\ThirdParty\VrmSdk'
          $req = @(
            'lib\Win64\Release\vrm_glb_parser.lib',
            'lib\Win64\Release\vrm_normalizers.lib',
            'lib\Win64\Release\vrm_validate.lib',
            'lib\Win64\Debug\vrm_glb_parser.lib',
            'lib\Win64\Debug\vrm_normalizers.lib',
            'lib\Win64\Debug\vrm_validate.lib'
          )
          foreach ($r in $req) {
            $p = Join-Path $root $r
            if (-not (Test-Path $p)) { throw "Missing required SDK file: $p" }
          }

          # Heuristic: Debug libs should usually be larger than Release.
          $pairs = @(
            @{ name = 'vrm_glb_parser.lib'; dbg = 'lib\Win64\Debug\vrm_glb_parser.lib'; rel = 'lib\Win64\Release\vrm_glb_parser.lib' },
            @{ name = 'vrm_normalizers.lib'; dbg = 'lib\Win64\Debug\vrm_normalizers.lib'; rel = 'lib\Win64\Release\vrm_normalizers.lib' },
            @{ name = 'vrm_validate.lib'; dbg = 'lib\Win64\Debug\vrm_validate.lib'; rel = 'lib\Win64\Release\vrm_validate.lib' }
          )

          $mirrored = @()
          foreach ($p in $pairs) {
            $dbg = Get-Item (Join-Path $root $p.dbg)
            $rel = Get-Item (Join-Path $root $p.rel)

            if ($dbg.Length -le $rel.Length) {
              $mirrored += "$($p.name) (Debug=$($dbg.Length) Release=$($rel.Length))"
            }
          }

          # Fail only if *all* look mirrored (strong signal).
          if ($mirrored.Count -eq $pairs.Count) {
            throw "All Debug libs are <= Release size; this strongly suggests Release->Debug mirroring: $($mirrored -join '; ')"
          }

          # Otherwise: warn, but don't fail (keeps CI robust).
          if ($mirrored.Count -gt 0) {
            Write-Warning "Some Debug libs are <= Release size (may be acceptable, but review): $($mirrored -join '; ')"
          }

      - name: Verify vrm_validate contract-smoke
        shell: pwsh
        run: .\Scripts\CheckVrmValidate.ps1

      - name: Verify UE_ENGINE_PATH
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: |
          if (-not $env:UE_ENGINE_PATH) { throw "UE_ENGINE_PATH secret is not set." }
          if (-not (Test-Path $env:UE_ENGINE_PATH)) { throw "UE_ENGINE_PATH does not exist: $env:UE_ENGINE_PATH" }
          Write-Host "UE_ENGINE_PATH OK: $env:UE_ENGINE_PATH"

      - name: Assert dev-tool staging disabled
        shell: pwsh
        run: |
          if ($env:VRM_TOOLCHAIN_STAGE_DEV_TOOLS) { throw "VRM_TOOLCHAIN_STAGE_DEV_TOOLS must not be set in CI (policy: no dev binaries staged)." }

      - name: Package plugin (BuildPlugin + strip dev exe + leak gate)
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: .\Scripts\PackagePlugin.ps1 -UE "$env:UE_ENGINE_PATH" -RepoRoot "$PWD" -PluginName "VrmToolchain"

      - name: Verify packaged output contains no SDK binaries and includes headers/libs
        shell: pwsh
        run: |
          $out = Join-Path $PWD 'build\Package\VrmToolchain'
          if (-not (Test-Path $out)) { throw "Expected package output not found: $out" }

          # Leak check: no .exe or .pdb under the staged SDK
          $leaks = Get-ChildItem $out -Recurse -Include "*.exe","*.pdb" -File -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -like "*\Source\ThirdParty\VrmSdk\*" }
          if ($leaks) {
            $leaks | ForEach-Object { Write-Error "LEAK: $($_.FullName)" }
            throw "SDK binary leak detected in packaged output."
          }

          # Ensure include and lib are present and non-empty
          $inc = Join-Path $out 'Source\ThirdParty\VrmSdk\include'
          if (-not (Test-Path $inc) -or -not (Get-ChildItem $inc -Recurse -File -ErrorAction SilentlyContinue)) {
            throw "Packaged plugin missing SDK include files at $inc"
          }

          $lib = Join-Path $out 'Source\ThirdParty\VrmSdk\lib'
          $libFiles = Get-ChildItem $lib -Recurse -Filter '*.lib' -File -ErrorAction SilentlyContinue
          if (-not $libFiles) { throw "Packaged plugin missing SDK library files under $lib" }

          Write-Host "OK: Packaged output audit passed (no SDK binaries; include/lib present)."
      - name: Zip packaged output
        shell: pwsh
        run: |
          $out = Join-Path $PWD 'build\Package\VrmToolchain'
          if (-not (Test-Path $out)) { throw "Expected package output not found: $out" }
          $zip = Join-Path $PWD 'VrmToolchain-Package.zip'
          if (Test-Path $zip) { Remove-Item $zip -Force }
          Compress-Archive -Path $out -DestinationPath $zip -Force

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: VrmToolchain-Package
          path: VrmToolchain-Package.zip

      - name: Stage VrmToolchain into HostProject Plugins
        shell: pwsh
        run: |
          $src = Join-Path $PWD 'Plugins\VrmToolchain'
          if (-not (Test-Path $src)) { throw "Plugin source not found: $src" }
          $dstDir = Join-Path $PWD 'HostProject\Plugins'
          $dst = Join-Path $dstDir 'VrmToolchain'
          if (Test-Path $dst) { Remove-Item -Recurse -Force $dst }
          New-Item -ItemType Directory -Path $dstDir -Force | Out-Null
          Copy-Item -Path $src -Destination $dst -Recurse -Force
          if (-not (Test-Path (Join-Path $dst 'VrmToolchain.uplugin'))) { throw "Plugin copy failed: $dst" }

      - name: Build HostProjectEditor (Win64, Development)
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: |
          if (-not $env:UE_ENGINE_PATH) { throw "UE_ENGINE_PATH secret is not set." }
          $build = Join-Path $env:UE_ENGINE_PATH 'Engine\Build\BatchFiles\Build.bat'
          if (-not (Test-Path $build)) { throw "Build.bat not found: $build" }
          & $build 'HostProjectEditor' 'Win64' 'Development' -project="$PWD\HostProject\HostProject.uproject"
          if ($LASTEXITCODE -ne 0) { throw "HostProjectEditor build failed (exit $LASTEXITCODE)" }

      - name: Run automation tests
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: |
          $editor = Join-Path $env:UE_ENGINE_PATH 'Engine\Binaries\Win64\UnrealEditor.exe'
          .\Scripts\RunAutomationTests.ps1 -EditorPath $editor -ProjectPath "$PWD\HostProject\HostProject.uproject" -TestFilter "VrmToolchain" -LogDir "$PWD\build\AutomationLogs" -ReportOutputPath "$PWD\build\AutomationReports"

      - name: Upload automation logs, reports & deterministic results
        uses: actions/upload-artifact@v4
        with:
          name: Automation-Logs
          path: |
            build/AutomationLogs/**
            build/AutomationReports/**
            build/TestResults/**
          retention-days: 7
        if: always()

      - name: Post automation results to PR (if applicable)
        if: github.event_name == 'pull_request'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $results = Join-Path $PWD 'build\TestResults\VrmToolchain_Results.json'
          if (Test-Path $results) { .\Scripts\PostAutomationResultsToPR.ps1 -ResultsFile $results } else { Write-Host "No deterministic results file found: $results" }

