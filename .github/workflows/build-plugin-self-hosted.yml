name: Build plugin (self-hosted)

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: build-plugin-self-hosted-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-plugin:
    runs-on: [self-hosted, windows, ue-5.7]
    steps:
      - uses: actions/checkout@v4

      - name: Determine changed files
        id: changed
        shell: pwsh
        run: |
          # Determine files changed against main and set docs_only output if only Docs/ or meta files changed
          if ($env:GITHUB_EVENT_NAME -eq 'pull_request') {
            git fetch origin main
            $changed = git diff --name-only origin/main...HEAD | Out-String
          } else {
            $changed = git diff --name-only HEAD~1 HEAD | Out-String
          }
          Write-Host "Changed files:`n$changed"
          $nonDocs = @($changed -split "`n" | Where-Object { $_ -and -not ($_ -match '^(Docs/|\\.github/|README.md|LICENSE|CHANGELOG)') })
          if ($nonDocs.Count -eq 0) {
            echo "docs_only=true" >> $env:GITHUB_OUTPUT
            Write-Host "Docs-only change detected"
          } else {
            echo "docs_only=false" >> $env:GITHUB_OUTPUT
            Write-Host "Non-doc changes detected"
          }

      - name: "Lint workflows: forbid -AllowBinaries"
        shell: pwsh
        run: |
          # Fail if any workflow calls PackagePlugin.ps1 with -AllowBinaries (forbidden by policy)
          $violations = @()
          foreach ($file in Get-ChildItem ".github/workflows/*.yml") {
            $lines = @(Get-Content $file -Encoding UTF8)
            $inRunBlock = $false
            for ($i = 0; $i -lt $lines.Count; $i++) {
              $line = $lines[$i]
              if ($line -match '^\s+run:\s*[\|\>]') { $inRunBlock = $true }
              if ($inRunBlock -and $line -match '^\s+- ') { $inRunBlock = $false }
              # Only check invocation lines: starts with .\ and actual PackagePlugin.ps1 call
              if ($inRunBlock -and $line -match '^\s+\.\\\Scripts\\PackagePlugin' -and $line -match '-AllowBinaries') {
                $violations += "$($file.Name):$($i+1)"
              }
            }
          }
          if ($violations) {
            $violations | ForEach-Object { Write-Error "Forbidden -AllowBinaries: $_" }
            throw "CI forbids PackagePlugin.ps1 with -AllowBinaries"
          }
          Write-Host "OK: Workflows do not call PackagePlugin.ps1 with -AllowBinaries"

      - name: Fetch VRM SDK
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        env:
          VRM_SDK_TOKEN: ${{ secrets.VRM_SDK_TOKEN }}
        run: .\Scripts\FetchVrmSdk.ps1

      - name: Verify SDK lib layout (Debug/Release present)
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        run: |
          $root = Join-Path $PWD 'Plugins\VrmToolchain\Source\ThirdParty\VrmSdk'
          $req = @(
            'lib\Win64\Release\vrm_glb_parser.lib',
            'lib\Win64\Release\vrm_normalizers.lib',
            'lib\Win64\Release\vrm_validate.lib',
            'lib\Win64\Debug\vrm_glb_parser.lib',
            'lib\Win64\Debug\vrm_normalizers.lib',
            'lib\Win64\Debug\vrm_validate.lib'
          )
          foreach ($r in $req) {
            $p = Join-Path $root $r
            if (-not (Test-Path $p)) { throw "Missing required SDK file: $p" }
          }

          # Heuristic: Debug libs should usually be larger than Release.
          $pairs = @(
            @{ name = 'vrm_glb_parser.lib'; dbg = 'lib\Win64\Debug\vrm_glb_parser.lib'; rel = 'lib\Win64\Release\vrm_glb_parser.lib' },
            @{ name = 'vrm_normalizers.lib'; dbg = 'lib\Win64\Debug\vrm_normalizers.lib'; rel = 'lib\Win64\Release\vrm_normalizers.lib' },
            @{ name = 'vrm_validate.lib'; dbg = 'lib\Win64\Debug\vrm_validate.lib'; rel = 'lib\Win64\Release\vrm_validate.lib' }
          )

          $mirrored = @()
          foreach ($p in $pairs) {
            $dbg = Get-Item (Join-Path $root $p.dbg)
            $rel = Get-Item (Join-Path $root $p.rel)

            if ($dbg.Length -le $rel.Length) {
              $mirrored += "$($p.name) (Debug=$($dbg.Length) Release=$($rel.Length))"
            }
          }

          # Fail only if *all* look mirrored (strong signal).
          if ($mirrored.Count -eq $pairs.Count) {
            throw "All Debug libs are <= Release size; this strongly suggests Release->Debug mirroring: $($mirrored -join '; ')"
          }

          # Otherwise: warn, but don't fail (keeps CI robust).
          if ($mirrored.Count -gt 0) {
            Write-Warning "Some Debug libs are <= Release size (may be acceptable, but review): $($mirrored -join '; ')"
          }

      - name: Verify vrm_validate contract-smoke
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        run: .\Scripts\CheckVrmValidate.ps1

      - name: Verify UE_ENGINE_PATH
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: |
          if (-not $env:UE_ENGINE_PATH) { throw "UE_ENGINE_PATH secret is not set." }
          if (-not (Test-Path $env:UE_ENGINE_PATH)) { throw "UE_ENGINE_PATH does not exist: $env:UE_ENGINE_PATH" }
          Write-Host "UE_ENGINE_PATH OK: $env:UE_ENGINE_PATH"

      - name: Assert dev-tool staging disabled
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        run: |
          if ($env:VRM_TOOLCHAIN_STAGE_DEV_TOOLS) { throw "VRM_TOOLCHAIN_STAGE_DEV_TOOLS must not be set in CI (policy: no dev binaries staged)." }

      - name: Package plugin (BuildPlugin + strip dev exe + leak gate)
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: .\Scripts\PackagePlugin.ps1 -UE "$env:UE_ENGINE_PATH" -RepoRoot "$PWD" -PluginName "VrmToolchain"

      - name: Verify packaged output contains no SDK binaries and includes headers/libs
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        run: |
          $out = Join-Path $PWD 'build\Package\VrmToolchain'
          if (-not (Test-Path $out)) { throw "Expected package output not found: $out" }

          # Leak check: no .exe or .pdb under the staged SDK
          $leaks = Get-ChildItem $out -Recurse -Include "*.exe","*.pdb" -File -ErrorAction SilentlyContinue |
            Where-Object { $_.FullName -like "*\Source\ThirdParty\VrmSdk\*" }
          if ($leaks) {
            $leaks | ForEach-Object { Write-Error "LEAK: $($_.FullName)" }
            throw "SDK binary leak detected in packaged output."
          }

          # Ensure include and lib are present and non-empty
          $inc = Join-Path $out 'Source\ThirdParty\VrmSdk\include'
          if (-not (Test-Path $inc) -or -not (Get-ChildItem $inc -Recurse -File -ErrorAction SilentlyContinue)) {
            throw "Packaged plugin missing SDK include files at $inc"
          }

          $lib = Join-Path $out 'Source\ThirdParty\VrmSdk\lib'
          $libFiles = Get-ChildItem $lib -Recurse -Filter '*.lib' -File -ErrorAction SilentlyContinue
          if (-not $libFiles) { throw "Packaged plugin missing SDK library files under $lib" }

          Write-Host "OK: Packaged output audit passed (no SDK binaries; include/lib present)."
      - name: Zip packaged output
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        run: |
          $out = Join-Path $PWD 'build\Package\VrmToolchain'
          if (-not (Test-Path $out)) { throw "Expected package output not found: $out" }
          $zip = Join-Path $PWD 'VrmToolchain-Package.zip'
          if (Test-Path $zip) { Remove-Item $zip -Force }
          Compress-Archive -Path $out -DestinationPath $zip -Force

      - name: Upload artifact
        if: steps.changed.outputs.docs_only != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: VrmToolchain-Package
          path: VrmToolchain-Package.zip

      - name: Stage VrmToolchain into HostProject Plugins
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        run: |
          $src = Join-Path $PWD 'Plugins\VrmToolchain'
          if (-not (Test-Path $src)) { throw "Plugin source not found: $src" }
          $dstDir = Join-Path $PWD 'HostProject\Plugins'
          $dst = Join-Path $dstDir 'VrmToolchain'
          if (Test-Path $dst) { Remove-Item -Recurse -Force $dst }
          New-Item -ItemType Directory -Path $dstDir -Force | Out-Null
          Copy-Item -Path $src -Destination $dst -Recurse -Force
          if (-not (Test-Path (Join-Path $dst 'VrmToolchain.uplugin'))) { throw "Plugin copy failed: $dst" }

      - name: Build HostProjectEditor (Win64, Development)
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: |
          if (-not $env:UE_ENGINE_PATH) { throw "UE_ENGINE_PATH secret is not set." }
          $build = Join-Path $env:UE_ENGINE_PATH 'Engine\Build\BatchFiles\Build.bat'
          if (-not (Test-Path $build)) { throw "Build.bat not found: $build" }
          & $build 'HostProjectEditor' 'Win64' 'Development' -project="$PWD\HostProject\HostProject.uproject"
          if ($LASTEXITCODE -ne 0) { throw "HostProjectEditor build failed (exit $LASTEXITCODE)" }

      - name: Run automation tests
        if: steps.changed.outputs.docs_only != 'true'
        shell: pwsh
        env:
          UE_ENGINE_PATH: ${{ secrets.UE_ENGINE_PATH }}
        run: |
          $editor = Join-Path $env:UE_ENGINE_PATH 'Engine\Binaries\Win64\UnrealEditor.exe'
          .\Scripts\RunAutomationTests.ps1 -EditorPath $editor -ProjectPath "$PWD\HostProject\HostProject.uproject" -TestFilter "VrmToolchain" -LogDir "$PWD\build\AutomationLogs" -ReportOutputPath "$PWD\build\AutomationReports"

      - name: Upload automation logs, reports & deterministic results
        uses: actions/upload-artifact@v4
        with:
          name: Automation-Logs
          path: |
            build/AutomationLogs/**
            build/AutomationReports/**
            build/TestResults/**
          retention-days: 7
        if: always()

      - name: Post automation results to PR (if applicable)
        if: github.event_name == 'pull_request'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $results = Join-Path $PWD 'build\TestResults\VrmToolchain_Results.json'
          if (Test-Path $results) { .\Scripts\PostAutomationResultsToPR.ps1 -ResultsFile $results } else { Write-Host "No deterministic results file found: $results" }

